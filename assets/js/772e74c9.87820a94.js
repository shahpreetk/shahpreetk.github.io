"use strict";(self.webpackChunkshahpreetk_github_io=self.webpackChunkshahpreetk_github_io||[]).push([[5495],{4034:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var i=t(7285),a=t(4848),r=t(8453);const o={slug:"multithreading-in-java",title:"Multithreading in Java",description:"Multithreading and Concurrency in Java are essential concepts for building scalable and responsive applications. This guide covers the basics of multithreading in Java.",authors:"shahpreetk",tags:["java","multithreading","race-condition","concurrency","lock","semaphore","monitor","synchronization"]},c=void 0,s={authorsImageUrls:[void 0]},l=[{value:"Introduction to Multithreading",id:"introduction-to-multithreading",level:2},{value:"Thread Class Example",id:"thread-class-example",level:3},{value:"Race Condition",id:"race-condition",level:2},{value:"Race Condition Example",id:"race-condition-example",level:3},{value:"Mitigating Race Conditions",id:"mitigating-race-conditions",level:2},{value:"Lock Example",id:"lock-example",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"introduction-to-multithreading",children:"Introduction to Multithreading"}),"\n",(0,a.jsx)(n.p,{children:"Multi-threading in Java enables a single process to manage multiple threads concurrently, allowing tasks to be executed in parallel. This is achieved through the Thread class or the Runnable interface, empowering developers to create and oversee threads for parallel task execution."}),"\n",(0,a.jsx)(n.h3,{id:"thread-class-example",children:"Thread Class Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'class MyThread extends Thread {\n    public void run() {\n        // Task to be performed concurrently\n        System.out.println("Thread running..."); // Printing a message indicating that the thread is running\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread1 = new MyThread(); // Creating an instance of MyThread\n        MyThread thread2 = new MyThread(); // Creating another instance of MyThread\n\n        // Starting threads\n        thread1.start(); // Starting the first thread\n        thread2.start(); // Starting the second thread\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"race-condition",children:"Race Condition"}),"\n",(0,a.jsx)(n.p,{children:"However, multi-threading can introduce race conditions, where program behavior depends on the timing of events, such as the order in which threads execute instructions. This unpredictability may lead to unexpected outcomes as threads concurrently access and modify shared resources, risking data corruption and program state inconsistencies."}),"\n",(0,a.jsx)(n.h3,{id:"race-condition-example",children:"Race Condition Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'class Counter {\n    private int count = 0; // Initializing the counter\n\n    // Method to increment the counter\n    public void increment() {\n        /**\n         * Since this method is accessed by multiple threads (thread1 and thread2), there is a possibility that both threads may execute this line concurrently.\n         * If both threads execute count++ at the same time, it can lead to a race condition where the final value of count may not be the expected result.\n         * This is because both threads are reading the current value of count, incrementing it, and then writing the updated value back to count.\n         * If these operations are not synchronized, the final result may be inconsistent due to interleaving of operations from different threads.\n        */\n        count++; // This operation leads to race condition\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter(); // Creating an instance of Counter\n\n        // Creating multiple threads to increment the counter\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter.increment(); // Incrementing the counter\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter.increment(); // Incrementing the counter\n            }\n        });\n\n        // Starting the threads\n        thread1.start(); // Starting the first thread\n        thread2.start(); // Starting the second thread\n\n        // Waiting for threads to complete\n        try {\n            thread1.join(); // Waiting for the first thread to complete\n            thread2.join(); // Waiting for the second thread to complete\n        } catch (InterruptedException e) {\n            e.printStackTrace(); // Handling InterruptedException\n        }\n\n        // Displaying the final count\n        System.out.println("Final count: " + counter.getCount()); // Printing the final count\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"mitigating-race-conditions",children:"Mitigating Race Conditions"}),"\n",(0,a.jsx)(n.p,{children:"To mitigate race conditions in Java, synchronization mechanisms like locks, semaphores, and monitors are utilized. These mechanisms control access to shared resources, ensuring that only one thread can access and modify the resource at a time. By preventing simultaneous access and modification of shared resources, these measures diminish the likelihood of data corruption and enhance program reliability."}),"\n",(0,a.jsx)(n.h3,{id:"lock-example",children:"Lock Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass Counter {\n    private int count = 0; // Initializing the counter\n\n    // Creating a lock for synchronization\n    private Lock lock = new ReentrantLock(); // Creating a lock\n\n    // Method to increment the counter using a lock\n    public void increment() {\n        lock.lock(); // Acquiring the lock\n        try {\n            count++; // Incrementing the counter\n        } finally {\n            lock.unlock(); // Releasing the lock\n        }\n    }\n\n    // Method to get the current value of the counter\n    public int getCount() {\n        return count;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter(); // Creating an instance of Counter\n\n        // Creating multiple threads to increment the counter\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter.increment(); // Incrementing the counter\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter.increment(); // Incrementing the counter\n            }\n        });\n\n        // Starting the threads\n        thread1.start();\n        thread2.start();\n\n        // Waiting for threads to complete\n        try {\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // Displaying the final count\n        System.out.println("Final count: " + counter.getCount());\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Multithreading and concurrency are crucial in Java for creating scalable and responsive apps. However, dealing with issues like race conditions requires careful attention. By using synchronization mechanisms, developers can handle these challenges and ensure their multithreaded apps run smoothly."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(6540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},7285:e=>{e.exports=JSON.parse('{"permalink":"/blog/multithreading-in-java","source":"@site/blog/2024-03-06/2024-03-06-multithreading-java.md","title":"Multithreading in Java","description":"Multithreading and Concurrency in Java are essential concepts for building scalable and responsive applications. This guide covers the basics of multithreading in Java.","date":"2024-03-06T00:00:00.000Z","tags":[{"inline":true,"label":"java","permalink":"/blog/tags/java"},{"inline":true,"label":"multithreading","permalink":"/blog/tags/multithreading"},{"inline":true,"label":"race-condition","permalink":"/blog/tags/race-condition"},{"inline":true,"label":"concurrency","permalink":"/blog/tags/concurrency"},{"inline":true,"label":"lock","permalink":"/blog/tags/lock"},{"inline":true,"label":"semaphore","permalink":"/blog/tags/semaphore"},{"inline":true,"label":"monitor","permalink":"/blog/tags/monitor"},{"inline":true,"label":"synchronization","permalink":"/blog/tags/synchronization"}],"readingTime":3.845,"hasTruncateMarker":true,"authors":[{"name":"Preet Shah","title":"Software Developer @ JPMC","url":"https://github.com/shahpreetk","description":"Preet Shah is a Full-Stack Software Developer at JP Morgan Chase, specialising in Java Spring Boot, Python and React. Preet is an AWS Certified Associate, currently aiming for her Developer Certification. In her free time, she enjoys crocheting, diving into murder mystery novels, and watching cat videos.","page":{"permalink":"/blog/authors/shahpreetk"},"socials":{"x":"https://x.com/shahpreetk","linkedin":"https://www.linkedin.com/in/shahpreetk/"},"imageURL":"https://github.com/shahpreetk.png\\\\","key":"shahpreetk"}],"frontMatter":{"slug":"multithreading-in-java","title":"Multithreading in Java","description":"Multithreading and Concurrency in Java are essential concepts for building scalable and responsive applications. This guide covers the basics of multithreading in Java.","authors":"shahpreetk","tags":["java","multithreading","race-condition","concurrency","lock","semaphore","monitor","synchronization"]},"unlisted":false,"prevItem":{"title":"Java Spring Boot Project - Part 1","permalink":"/blog/setting-up-a-java-spring-boot-project-part-1"},"nextItem":{"title":"Garbage Collector in Java","permalink":"/blog/garbage-collector-in-java"}}')}}]);